package rmit.saintgiong.discoveryservice.searchprofile.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Named;
import org.mapstruct.NullValuePropertyMappingStrategy;
import rmit.saintgiong.discoveryapi.internal.dto.CreateSearchProfileRequestDto;
import rmit.saintgiong.discoveryapi.internal.dto.UpdateSearchProfileRequestDto;
import rmit.saintgiong.discoveryapi.internal.dto.SearchProfileResponseDto;
import rmit.saintgiong.discoveryservice.common.degree.type.DegreeType;
import rmit.saintgiong.discoveryservice.common.degree.type.EmploymentTypeEnum;
import rmit.saintgiong.discoveryservice.common.exception.InvalidEnumValueException;
import rmit.saintgiong.discoveryservice.searchprofile.entity.SearchProfileEntity;
import rmit.saintgiong.discoveryservice.searchprofile.entity.SearchProfile_SkillTagEntity;

import java.util.BitSet;
import java.util.Collections;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

@Mapper(componentModel = "spring")
public abstract class SearchProfileMapper {

    /**
     * Converts a SearchProfileEntity to SearchProfileResponseDto.
     *
     * @param savedProfile the entity to convert
     * @return the response DTO with mapped fields
     */
    @Mapping(target = "employmentTypes", source = "employmentType", qualifiedByName = "mapBitSetToStrings")
    @Mapping(target = "skillTagIds", source = "skillTags", qualifiedByName = "mapSkillTagsToIds")
    public abstract SearchProfileResponseDto entityToResponseDto(SearchProfileEntity savedProfile);

    /**
     * Converts a BitSet representation of employment types to a Set of enum names.
     *
     * @param bitSet the BitSet storing employment type indices
     * @return a Set of employment type names (e.g., "FULL_TIME", "PART_TIME")
     */
    @Named("mapBitSetToStrings")
    protected Set<String> mapBitSetToStrings(BitSet bitSet) {
        // Return empty set if BitSet is null or has no bits set
        if (bitSet == null || bitSet.isEmpty()) {
            return Collections.emptySet();
        }

        // Stream through each set bit index and map to corresponding enum name
        return bitSet.stream()
                .mapToObj(index -> {
                    // Find the Enum matching this bit index
                    for (EmploymentTypeEnum e : EmploymentTypeEnum.values()) {
                        if (e.getBitIndex() == index) {
                            return e.name();
                        }
                    }
                    return null;
                })
                // Filter out any null values (indices without matching enum)
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());
    }


    /**
     * Extracts skill tag IDs from the join entity collection.
     *
     * @param skillTags the Set of join entities linking profiles to skill tags
     * @return a Set of Integer tag IDs
     */
    @Named("mapSkillTagsToIds")
    protected Set<Integer> mapSkillTagsToIds(Set<SearchProfile_SkillTagEntity> skillTags) {
        // Return empty set if no skill tags are associated
        if (skillTags == null) {
            return Collections.emptySet();
        }
        // Extract tagId from each join entity's composite key
        return skillTags.stream()
                .map(entity -> entity.getSkillTagId().getTagId())
                .collect(Collectors.toSet());
    }


    /**
     * Converts a CreateSearchProfileRequestDto to SearchProfileEntity.
     *
     * @param dto the request DTO containing profile creation data
     * @return the entity ready for persistence
     */
    @Mapping(target = "profileId", ignore = true) // Generated by DB
    @Mapping(target = "skillTags", ignore = true) // Handled in Service
    @Mapping(target = "employmentType", source = "employmentTypes", qualifiedByName = "mapStringsToBitSet")
    @Mapping(target = "highestDegree", source = "highestDegree", qualifiedByName = "mapStringToDegreeType")
    public abstract SearchProfileEntity requestDtoToEntity(CreateSearchProfileRequestDto dto);

    /**
     * Updates an existing SearchProfileEntity with non-null values from UpdateSearchProfileRequestDto.
     * Uses partial update strategy - only non-null fields in the DTO will overwrite entity fields.
     *
     * @param dto    the update request DTO containing fields to update
     * @param entity the existing entity to be updated
     */
    @Mapping(target = "profileId", ignore = true) // ID should not be changed
    @Mapping(target = "skillTags", ignore = true) // Handled separately in Service
    @Mapping(target = "companyId", ignore = true) // Company ownership should not change
    @Mapping(target = "employmentType", source = "employmentTypes", qualifiedByName = "mapStringsToBitSet", nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "highestDegree", source = "highestDegree", qualifiedByName = "mapStringToDegreeType", nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "salaryMin", nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "salaryMax", nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "country", nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    public abstract void updateEntityFromDto(UpdateSearchProfileRequestDto dto, @MappingTarget SearchProfileEntity entity);

    /**
     * Converts a degree type string to DegreeType enum.
     *
     * @param degree the string representation of degree type
     * @return the corresponding DegreeType enum value, or null if input is blank
     * @throws InvalidEnumValueException if the degree string doesn't match any enum value
     */
    @Named("mapStringToDegreeType")
    protected DegreeType mapStringToDegreeType(String degree) {
        // Allow null or blank values (optional field)
        if (degree == null || degree.isBlank()) {
            return null;
        }
        try {
            // Attempt to parse the string to enum (case-insensitive)
            return DegreeType.valueOf(degree.toUpperCase());
        } catch (IllegalArgumentException e) {
            // Throw custom exception with valid options for better error message
            throw new InvalidEnumValueException(
                    "degree type",
                    degree,
                    new String[]{"BACHELOR", "MASTER", "DOCTORATE"});
        }
    }

    /**
     * Converts a Set of employment type strings to a BitSet representation.
     *
     * @param types the Set of employment type names (e.g., "FULL_TIME", "PART_TIME")
     * @return a BitSet with bits set at positions corresponding to each employment type
     * @throws InvalidEnumValueException if any type string doesn't match a valid enum value
     */
    @Named("mapStringsToBitSet")
    protected BitSet mapStringsToBitSet(Set<String> types) {
        // Return empty BitSet if no employment types provided
        if (types == null || types.isEmpty()) {
            return new BitSet();
        }
        BitSet bitSet = new BitSet();
        // Iterate through each type string and set corresponding bit
        for (String type : types) {
            try {
                // Get the bit index for this employment type enum
                int index = EmploymentTypeEnum.getIndexByName(type);
                // Set the bit at that index to represent this employment type
                bitSet.set(index);
            } catch (IllegalArgumentException e) {
                // Throw custom exception with valid options for better error message
                throw new InvalidEnumValueException(
                        "employment type",
                        type,
                        new String[]{"FULL_TIME", "PART_TIME", "FRESHER", "INTERNSHIP", "CONTRACT"});
            }
        }
        return bitSet;
    }


}